From 6802c8ab7f663614c960653566706193257572b1 Mon Sep 17 00:00:00 2001
From: Schischu <schischu65@gmail.com>
Date: Fri, 9 Jan 2015 18:52:33 +0100
Subject: [PATCH 1/2] [lt03lte] kernel compatibility

---
 mm-video-v4l2/vidc/vdec.mk                         |  1 +
 mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp   | 29 +++++++++++++++++++---
 mm-video-v4l2/vidc/venc.mk                         |  3 ++-
 .../vidc/venc/src/video_encoder_device_v4l2.cpp    | 16 ++++++++++++
 4 files changed, 45 insertions(+), 4 deletions(-)

diff --git a/mm-video-v4l2/vidc/vdec.mk b/mm-video-v4l2/vidc/vdec.mk
index 998cf5b..175b304 100644
--- a/mm-video-v4l2/vidc/vdec.mk
+++ b/mm-video-v4l2/vidc/vdec.mk
@@ -42,6 +42,7 @@ libOmxVdec-def += -DMAX_RES_1080P_EBI
 libOmxVdec-def += -DPROCESS_EXTRADATA_IN_OUTPUT_PORT
 libOmxVdec-def += -D_MSM8974_
 libOmxVdec-def += -D_HEVC_USE_ADSP_HEAP_
+libOmxVdec-def += -D_ION_HEAP_MASK_COMPATIBILITY_WA
 endif
 ifeq ($(TARGET_BOARD_PLATFORM),msm7627a)
 libOmxVdec-def += -DMAX_RES_720P
diff --git a/mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp b/mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp
index 2fbdff8..42e41f5 100755
--- a/mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp
+++ b/mm-video-v4l2/vidc/vdec/src/omx_vdec_msm8974.cpp
@@ -1629,6 +1629,7 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
         codec_type_parse = CODEC_TYPE_H264;
         m_frame_parser.init_start_codes (codec_type_parse);
         m_frame_parser.init_nal_length(nal_length);
+#ifdef VDEC_CODECTYPE_MVC
     } else if (!strncmp(drv_ctx.kind, "OMX.qcom.video.decoder.mvc",\
                 OMX_MAX_STRINGNAME_SIZE)) {
         strlcpy((char *)m_cRole, "video_decoder.mvc", OMX_MAX_STRINGNAME_SIZE);
@@ -1638,6 +1639,7 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
         codec_type_parse = CODEC_TYPE_H264;
         m_frame_parser.init_start_codes(codec_type_parse);
         m_frame_parser.init_nal_length(nal_length);
+#endif
     } else if (!strncmp(drv_ctx.kind, "OMX.qcom.video.decoder.hevc",\
                 OMX_MAX_STRINGNAME_SIZE)) {
         strlcpy((char *)m_cRole, "video_decoder.hevc",OMX_MAX_STRINGNAME_SIZE);
@@ -1799,6 +1801,7 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
                 return OMX_ErrorInsufficientResources;
             }
         }
+#ifdef VDEC_CODECTYPE_MVC
         if (output_capability == V4L2_PIX_FMT_H264_MVC) {
             control.id = V4L2_CID_MPEG_VIDC_VIDEO_MVC_BUFFER_LAYOUT;
             control.value = V4L2_MPEG_VIDC_VIDEO_MVC_TOP_BOTTOM;
@@ -1808,6 +1811,7 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
                 return OMX_ErrorInsufficientResources;
             }
         }
+#endif
 
         /*Get the Buffer requirements for input and output ports*/
         drv_ctx.ip_buf.buffer_type = VDEC_BUFFER_TYPE_INPUT;
@@ -1837,9 +1841,14 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
         eRet=get_buffer_req(&drv_ctx.ip_buf);
         DEBUG_PRINT_HIGH("Input Buffer Size =%d",drv_ctx.ip_buf.buffer_size);
         get_buffer_req(&drv_ctx.op_buf);
+#ifdef VDEC_CODECTYPE_MVC
         if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||
-                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC ||
+                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC || 
                 drv_ctx.decoder_format == VDEC_CODECTYPE_MVC) {
+#else
+        if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||
+                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC) {
+#endif
                     h264_scratch.nAllocLen = drv_ctx.ip_buf.buffer_size;
                     h264_scratch.pBuffer = (OMX_U8 *)malloc (drv_ctx.ip_buf.buffer_size);
                     h264_scratch.nFilledLen = 0;
@@ -1850,8 +1859,12 @@ OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)
                         return OMX_ErrorInsufficientResources;
                     }
         }
-        if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||
-            drv_ctx.decoder_format == VDEC_CODECTYPE_MVC) {
+#ifdef VDEC_CODECTYPE_MVC
+        if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264
+            || drv_ctx.decoder_format == VDEC_CODECTYPE_MVC) {
+#else
+        if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) {
+#endif
             if (m_frame_parser.mutils == NULL) {
                 m_frame_parser.mutils = new H264_Utils();
                 if (m_frame_parser.mutils == NULL) {
@@ -8923,7 +8936,11 @@ OMX_ERRORTYPE omx_vdec::enable_extradata(OMX_U32 requested_extradata,
                 DEBUG_PRINT_HIGH("Failed to set panscan extradata");
             }
             control.id = V4L2_CID_MPEG_VIDC_VIDEO_EXTRADATA;
+#ifdef V4L2_MPEG_VIDC_EXTRADATA_ASPECT_RATIO
             control.value = V4L2_MPEG_VIDC_EXTRADATA_ASPECT_RATIO;
+#else
+            control.value = V4L2_MPEG_VIDC_INDEX_EXTRADATA_ASPECT_RATIO;
+#endif
             if (ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &control)) {
                 DEBUG_PRINT_HIGH("Failed to set panscan extradata");
             }
@@ -8968,6 +8985,7 @@ OMX_ERRORTYPE omx_vdec::enable_extradata(OMX_U32 requested_extradata,
                 DEBUG_PRINT_HIGH("Failed to set frame bits info extradata");
             }
         }
+#ifdef V4L2_MPEG_VIDC_EXTRADATA_STREAM_USERDATA
         if (requested_extradata & OMX_EXTNUSER_EXTRADATA) {
             control.id = V4L2_CID_MPEG_VIDC_VIDEO_EXTRADATA;
             control.value = V4L2_MPEG_VIDC_EXTRADATA_STREAM_USERDATA;
@@ -8975,6 +8993,7 @@ OMX_ERRORTYPE omx_vdec::enable_extradata(OMX_U32 requested_extradata,
                 DEBUG_PRINT_HIGH("Failed to set stream userdata extradata");
             }
         }
+#endif
     }
     ret = get_buffer_req(&drv_ctx.op_buf);
     return ret;
@@ -9648,10 +9667,12 @@ bool omx_vdec::allocate_color_convert_buf::set_color_format(
     }
     pthread_mutex_lock(&omx->c_lock);
     if (omx->drv_ctx.output_format == VDEC_YUV_FORMAT_NV12)
+#ifdef VDEC_CODECTYPE_MVC
         if (omx->drv_ctx.decoder_format == VDEC_CODECTYPE_MVC)
             drv_color_format = (OMX_COLOR_FORMATTYPE)
                 QOMX_COLOR_FORMATYUV420PackedSemiPlanar32mMultiView;
         else
+#endif
         drv_color_format = (OMX_COLOR_FORMATTYPE)
             QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;
     else {
@@ -9911,10 +9932,12 @@ bool omx_vdec::allocate_color_convert_buf::get_color_format(OMX_COLOR_FORMATTYPE
     bool status = true;
     if (!enabled) {
         if (omx->drv_ctx.output_format == VDEC_YUV_FORMAT_NV12)
+#ifdef VDEC_CODECTYPE_MVC
             if (omx->drv_ctx.decoder_format == VDEC_CODECTYPE_MVC)
                     dest_color_format = (OMX_COLOR_FORMATTYPE)
                         QOMX_COLOR_FORMATYUV420PackedSemiPlanar32mMultiView;
                 else
+#endif
             dest_color_format =  (OMX_COLOR_FORMATTYPE)
                 QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;
         else
diff --git a/mm-video-v4l2/vidc/venc.mk b/mm-video-v4l2/vidc/venc.mk
index ae3de49..58bba49 100644
--- a/mm-video-v4l2/vidc/venc.mk
+++ b/mm-video-v4l2/vidc/venc.mk
@@ -33,8 +33,9 @@ endif
 ifeq ($(TARGET_BOARD_PLATFORM),msm8974)
 libmm-venc-def += -DMAX_RES_1080P
 libmm-venc-def += -DMAX_RES_1080P_EBI
-libOmxVdec-def += -DPROCESS_EXTRADATA_IN_OUTPUT_PORT
+libmm-venc-def += -DPROCESS_EXTRADATA_IN_OUTPUT_PORT
 libmm-venc-def += -D_MSM8974_
+libmm-venc-def += -D_ION_HEAP_MASK_COMPATIBILITY_WA
 endif
 ifeq ($(TARGET_BOARD_PLATFORM),msm7627a)
 libmm-venc-def += -DMAX_RES_720P
diff --git a/mm-video-v4l2/vidc/venc/src/video_encoder_device_v4l2.cpp b/mm-video-v4l2/vidc/venc/src/video_encoder_device_v4l2.cpp
index 83949ee..986bc4b 100755
--- a/mm-video-v4l2/vidc/venc/src/video_encoder_device_v4l2.cpp
+++ b/mm-video-v4l2/vidc/venc/src/video_encoder_device_v4l2.cpp
@@ -1194,6 +1194,7 @@ bool venc_dev::venc_set_param(void *paramData,OMX_INDEXTYPE index )
                     if (!venc_set_color_format(portDefn->format.video.eColorFormat)) {
                         return false;
                     }
+#ifdef V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_X_RANGE
                     if ((display_info.w * display_info.h) > (OMX_CORE_720P_WIDTH * OMX_CORE_720P_HEIGHT)
                         && enable_mv_narrow_searchrange &&
                         (m_sVenc_cfg.input_width * m_sVenc_cfg.input_height) >=
@@ -1202,6 +1203,7 @@ bool venc_dev::venc_set_param(void *paramData,OMX_INDEXTYPE index )
                             DEBUG_PRINT_ERROR("ERROR: Failed to set search range");
                         }
                     }
+#endif
                     if (m_sVenc_cfg.input_height != portDefn->format.video.nFrameHeight ||
                             m_sVenc_cfg.input_width != portDefn->format.video.nFrameWidth) {
                         DEBUG_PRINT_LOW("Basic parameter has changed");
@@ -1557,6 +1559,7 @@ bool venc_dev::venc_set_param(void *paramData,OMX_INDEXTYPE index )
 
                 break;
             }
+#ifdef V4L2_CID_MPEG_VIDC_VIDEO_I_FRAME_QP
         case QOMX_IndexParamVideoInitialQp:
             {
                 QOMX_EXTNINDEX_VIDEO_INITIALQP * initqp =
@@ -1571,6 +1574,7 @@ bool venc_dev::venc_set_param(void *paramData,OMX_INDEXTYPE index )
                     DEBUG_PRINT_ERROR("ERROR: setting QOMX_IndexParamVideoEnableInitialQp");
                 break;
             }
+#endif
         case OMX_QcomIndexParamVideoQPRange:
             {
                 DEBUG_PRINT_LOW("venc_set_param:OMX_QcomIndexParamVideoQPRange");
@@ -1727,6 +1731,7 @@ bool venc_dev::venc_set_param(void *paramData,OMX_INDEXTYPE index )
                 }
                 break;
             }
+#ifdef V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_X_RANGE
        case OMX_QcomIndexParamSetMVSearchrange:
             {
                DEBUG_PRINT_LOW("venc_set_config: OMX_QcomIndexParamSetMVSearchrange");
@@ -1737,6 +1742,7 @@ bool venc_dev::venc_set_param(void *paramData,OMX_INDEXTYPE index )
                }
             }
             break;
+#endif
         case OMX_IndexParamVideoSliceFMO:
         default:
             DEBUG_PRINT_ERROR("ERROR: Unsupported parameter in venc_set_param: %u",
@@ -2016,9 +2022,11 @@ unsigned venc_dev::venc_start(void)
 {
     enum v4l2_buf_type buf_type;
     int ret, r;
+#ifdef V4L2_CID_MPEG_VIDC_VIDEO_REQUEST_SEQ_HEADER
     struct v4l2_control control;
 
     memset(&control, 0, sizeof(control));
+#endif
 
     DEBUG_PRINT_HIGH("%s(): Check Profile/Level set in driver before start",
             __func__);
@@ -2057,6 +2065,7 @@ unsigned venc_dev::venc_start(void)
 
     streaming[CAPTURE_PORT] = true;
 
+#ifdef V4L2_CID_MPEG_VIDC_VIDEO_REQUEST_SEQ_HEADER
     control.id = V4L2_CID_MPEG_VIDC_VIDEO_REQUEST_SEQ_HEADER;
     control.value = 1;
     ret = ioctl(m_nDriver_fd, VIDIOC_S_CTRL, &control);
@@ -2064,6 +2073,7 @@ unsigned venc_dev::venc_start(void)
         DEBUG_PRINT_ERROR("failed to request seq header");
         return 1;
     }
+#endif
 
     stopped = 0;
     return 0;
@@ -2655,6 +2665,7 @@ bool venc_dev::venc_set_slice_delivery_mode(OMX_U32 enable)
     return true;
 }
 
+#ifdef V4L2_CID_MPEG_VIDC_VIDEO_I_FRAME_QP
 bool venc_dev::venc_enable_initial_qp(QOMX_EXTNINDEX_VIDEO_INITIALQP* initqp)
 {
     int rc;
@@ -2699,6 +2710,7 @@ bool venc_dev::venc_enable_initial_qp(QOMX_EXTNINDEX_VIDEO_INITIALQP* initqp)
                     controls.controls[3].id, controls.controls[3].value);
     return true;
 }
+#endif
 
 bool venc_dev::venc_set_session_qp(OMX_U32 i_frame_qp, OMX_U32 p_frame_qp,OMX_U32 b_frame_qp)
 {
@@ -3143,11 +3155,13 @@ bool venc_dev::venc_set_intra_period(OMX_U32 nPFrames, OMX_U32 nBFrames)
             (codec_profile.profile != V4L2_MPEG_VIDEO_H264_PROFILE_HIGH)) {
         nBFrames=0;
     }
+#ifdef V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_X_RANGE
     if ((display_info.w * display_info.h > OMX_CORE_720P_WIDTH * OMX_CORE_720P_HEIGHT)
         && enable_mv_narrow_searchrange && (m_sVenc_cfg.input_width * m_sVenc_cfg.input_height >=
         OMX_CORE_1080P_WIDTH * OMX_CORE_1080P_HEIGHT || is_searchrange_set)) {
         nBFrames=0;
     }
+#endif
 
     control.id = V4L2_CID_MPEG_VIDC_VIDEO_NUM_P_FRAMES;
     control.value = nPFrames;
@@ -3811,6 +3825,7 @@ bool venc_dev::venc_set_vpe_rotation(OMX_S32 rotation_angle)
 
 bool venc_dev::venc_set_searchrange()
 {
+#ifdef V4L2_CID_MPEG_VIDC_VIDEO_IFRAME_X_RANGE
     DEBUG_PRINT_LOW("venc_set_searchrange");
     struct v4l2_control control;
     struct v4l2_ext_control ctrl[6];
@@ -3881,6 +3896,7 @@ bool venc_dev::venc_set_searchrange()
         DEBUG_PRINT_ERROR("Failed to set search range %d", rc);
         return false;
     }
+#endif
     return true;
 }
 
-- 
2.1.4

